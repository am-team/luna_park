# Объект-Значение (Value)
> \- Какого роста твоя подруга?
> \- 151
> \- Ты стал встречаться со статуей свободы?

Примерно такой разговор мог бы произойти в штате Индиана. Рост человека это не просто число, но еще и единица измерения. Не всегда атрибуты объекта можно описать только примитивами (Integer, String, Boolean и т.п.), иногда требуются их комбинации:
- Деньги это не просто число, это число (сумма) + валюта.
- Дата состоит из числа, месяца и года.
- Чтобы измерить вес нам недостаточно одного числа, требуется еще и единица измерения.
- Номер паспорта состоит из серии и, собственно, из номера.

С другой стороны это не всегда комбинация, возможно это некое расширение примитива.
Телефонный номер зачастую воспринимается как число. С другой стороны, вряд ли у него должен быть метод сложения или деления. Возможно, есть метод, который будет выдавать код страны и метод, определяющий код города. Возможно, будет некий декоративный метод, который представит его не просто строкой чисел `79001231212`, а читаемой строкой: `7-900-123-12-12`.

<spoiler title="а может в декоратор?">

Если исходить из догм, то бесспорно - да. Если подходить к этой дилемме со стороны здравого смысла, то когда мы решим позвонить по этому номеру, то передадим телефону сам объект:

```ruby
phone.call Values::PhoneNumber.new(79001231212)
```
А если мы решили его представить в виде строки, то это явно сделано для человека. Так почему бы нам не сделать эту строку для человека сразу читаемой?
```ruby
Values::PhoneNumber.new(79001231212).to_s
```
</spoiler>

Представим, что мы создаем сайт онлайн-казино "Три топора" и реализуем карточные игры. Нам понадобится класс 'игральная карта'.

```ruby
module Values
  class PlayingCard < Lunapark::Values::Compound
    attr_reader :suit, :rank
  end
end
```
Итак, у нашего класса есть два атрибута только для чтения:
- suit - масть карты
- rank - достоинство карты

Эти атрибуты задаются только при создании карты и не могут изменятся при ее использовании. Вы конечно можете взять игральную карту и перечеркнуть <s>8</s>, написать Q, но это недопустимо. В  приличном обществе вас, скорее всего, пристрелят. Невозможность менять атрибуты после создания объекта определяет первое свойство _Объекта-значения_ - иммутабельность.
Вторым важным свойством _Объекта-Значения_ будет то, как мы их сравниваем.

```ruby
module Values
  RSpec.describe PlayingCard  do
    let(:card)  { described_class.new suit: :clubs, rank: 10 }
    let(:other) { described_class.new suit: :clubs, rank: 10 }
    it 'should be eql' do
      expect(card).to eq other
    end
  end
end
```
Такой тест не пройдет, так как они будут сравниваться по адресу. Чтобы тест прошел, мы должны сравнивать _Value-Obects_ по значению, для этого допишем метод сравнения:
```ruby
def ==(other)
  suit == other.suit &&
  rank == other.rank
end
```
Теперь наш тест пройдет. Мы также можем дописать методы, которые отвечают за сравнение, но как нам сравнить 10 и K ? Как вы уже, наверное, догадались, мы тоже их представим в виде _Объектов-Значений_. Ок, значит теперь мы должны будем инициировать десятку трефа так:
```ruby
ten       = Values::Rank.new('10')
clubs     = Values::Suits.new(:clubs)
ten_clubs = Values::PlayingCards.new(rank: ten, clubs: clubs)
```
Три строчки это достаточно много для ruby. Для того, чтобы обойти это ограничение, мы введем третье свойство _Объекта-Значения_ - оборачиваемость. Пусть у нас появится специальный метод  класса `.wrap`, который может принимать значения различного типа и преобразовывать их в нужный.
```ruby
class PlayingCard < Lunapark::Values::Compound
  def self.wrap(obj)
    case self   # Если мы получили объект класса PlayingCard
      obj       # то мы его и вернем
    case Hash   # Если мы получили хэш, то создадим на его основе
      new(obj)  # Новую игральную карту
    case String # Если мы получили строку, то последний символ будет
      new rank: obj[0..-2], suit:[-1]  # мастью, остальные - достоинством карты.
    else                  # если тип не совпадает с ожидаемым
      raise ArgumentError # выдаем ошибку.
    end
  end
  def initialize(suit:, rank:) # Еще модифицируем инициализатор класса
     @suit = Suit.wrap(suit)   # Это позволит нам оборачивать значения
     @rank = Rank.wrap(rank)
  end
 end
```
Такой подход дает большое преимущество:
```ruby
ten         = Values::Rank.new('10')
clubs       = Values::Suits.new(:clubs)
from_values = Values::PlayingCard.wrap rank: ten,  suit: clubs
from_hash   = Values::PlayingCard.wrap rank: '10', suit: :clubs
from_obj    = Values::PlayingCard.wrap from_values
from_str    = Values::PlayingCard.wrap '10C' # тут хотелось бы использовать симол треф из utf кодировки, но хабр, их обрезает.
```
Все эти карты будут равны между собой. Если метод `wrap` разрастается хорошей практикой, будет вынесение его в отдельный класс. С точки зрения догматического подхода отдельный класс так же будет обязательным.
Хм, а как насчет места в колоде? Как узнать, является ли данная карта козырем? Это не игральная карта. Это _Значение_ игральной карты. Это именно та надпись 10, которую вы ведите на углу картона.
К _Объекту-Значению_ нужно относится также, как и к примитиву, который почему-то не реализовали в ruby. Отсюда возникает последнее свойство -  _Объект-Значение_ не привязан ни к какому домену.

## Рекомендации
> Среди всего многообразия методов и инструментов, используемых в каждый момент каждого процесса, всегда есть один метод и инструмент, который работает быстрее и лучше остальных.
>
> [Фредерик Тейлор](https://ru.wikipedia.org/wiki/%D0%A4%D1%80%D0%B5%D0%B4%D0%B5%D1%80%D0%B8%D0%BA_%D0%A2%D0%B5%D0%B9%D0%BB%D0%BE%D1%80) 1914

##### Арифметические операции должны возвращать новый объект

```ruby
# GOOD
class Money < LunaPark::Values::Compound
  def +(other)
    other = self.class.wrap(other)
    raise ArgumentError unless same_currency? other
    self.class.new(
      amount: amount + other.amount,
      currency: currency
    )
  end
end
```

##### Атрибуты _Объекта-Значения_ могу быть только примитивами или другими _Объектами-значения_

```ruby
# GOOD
class Weight < LunaPark::Values::Compound
  def intialize(value:, unit:)
    @value = value
    @unit  = Unit.wrap(unit)
  end
end

# BAD
class PlaingCard < LunaPark::Value
  def initialize(rank:, suit:, deck:)
    ...
    @deck = Entity::Deck.wrap(deck) # зависимость от сущности
  end
end
```

##### Простые операции держите внутри методов класса

```ruby
# GOOD
class Weight < LunaPark::Values::Compound
  def >(other)
    value > other.convert_to(unit).value
  end
end
```

##### Если операция "конвертация" большая, то возможно есть смысл вынести ее в отдельный класс

```ruby
# UGLY
class Weight < LunaPark::Values::Compound
  def convert_to(unit)
    unit = Unit.wrap(unit)
    case { self.unit.to_sym => unit.to_sym }
    when { :kg => :ft }
      Weight.new(value: 2.2046 * value, unit.to_sym)
    when
      # ...
    end
  end
end

# GOOD
#./lib/values/weight/converter.rb
class Weight
  class Converter < LunaPark::Services::Simple
    def initialize(weight, to:)
      ...
    end
  end
end
#./lib/values/weight.rb
class Weight < LunaPark::Values::Compound
  def convert_to(unit)
    Converter.call! self, to: unit
  end
end
```

Такое вынесение логики в отдельный _Сервис_ возможно __только__ при условии того, что _Сервис_ изолирован: он не использует данные ни с каких внешних источников. Этот сервис должен быть ограничен контекстом самого _Объекта-Значения_

##### Объект значение не может ничего знать о доменной логике
Предположим, что мы пишем интернет магазин, и у нас есть рейтинг товаров. Чтобы его получить, необходимо сделать запрос в БД через _Репозиторий_.
```ruby
# DEADLY BAD
class Rate < LunaPark::Values::Single
  def top?(10)
    Repository::Rates.top(first: 10).include? self
  end
end
```
