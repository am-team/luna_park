# Объект-Значение (Value)

> \- Какого роста твоя подруга?
>
> \- 151
>
> \- Как у нашей статуи свободы?
> Примерно такой разговор мог бы произойти в штате Индиана. Рост человека, это не просто число, но еще и единица измерения. Не всегда атрибуты объекта можно описать только примитивами (Integer, String, Boolean и т.п.) иногда требуются их комбинации:
- Деньги это не просто число - это число (сумма) + валюта.
- Дата состоит из числа, месяца и года.
- Чтобы измерить вес нам недостаточно одного числа, треубется еще и единица измерения.
- Номер паспорта состоит из серии и собственно из номера.

С другой стороны это не всегда комбинация, возможно это некое расширение примитива,
телефонный номер это вроде просто число. С другой стороны вряд ли у него должен быть метод сложения или деления. Возможно есть метод который будет выдавать код страны и метод определяющий код города. Возможно будет некий декоративный метод который представит его не просто строкой чисел `79001231212`, а читаемой строкой: `7-900-123-12-12`.

<spoiler title="а может в декоратор?">

Если исходить из догм, то бесспорно - да. Если подходить к этой дилемме со стороны здравого смысла, то когда мы решим позвонить по этому номеру, то мы передадим телефону сам объект:

```ruby
phone.call Values::PhoneNumber.new(79001231212)
```
А если мы решили его представить в виде строки, то это явно сделано для человека. Так почему бы нам не сделать эту строку для человека сразу читаемой?
```ruby
Values::PhoneNumber.new(79001231212).to_s
```
</spoiler>

Представим, что мы создаем онлайн казино. И реализуем карточные игры. Нам понадобится класс 'игральная карта'.

```ruby
module Values
  class PlayingCard < Lunapark::Value
    attr_reader :siut, :rank
    def initialize(suit:, rank:)
      @siut = suit
      @rank = rank
    end
  end
end
```
Итак у нашего класса есть два атрибута, только для чтения:
- siut - масть карты
- rank - достоинство карты

Эти атрибуты задаются только при создании карты и не могут изменятся при ее использовании. Вы конечно можете взять игральную карту и перечеркнуть --8-- и написать Q. Но это недопустимо в  приличном обществе, вас скорее всего пристрелят. Невозможность менять атрибуты, после создания объекта определяет первой свойство _Объекта-значения_ - Иммутабельность.
Вторым важным свойством _Объекта-Значения_ будет то, как мы их сравниваем.

```ruby
module Values
  RSpec.describe PlayingCard  do
    let(:card)  { described_class.new suit: :clubs, rank: 10 }
    let(:other) { described_class.new suit: :clubs, rank: 10 }
    it 'should be eql' do
      expect(card).to eq other
    end
  end
end
```
Такой тест не пройдет так как они будут сравниваться по адресу. Чтобы тест прошел мы должны сравнивать _Value-Obects_ по значению, для этого допишем метод сравнения:
```ruby
def ==(other)
  suit == other.suit &&
  rank == other.rank
end
```
Теперь наш тест пройдет. Мы также можем дописать методы которые отвечают за сравнение, но как нам сравнить 10 и 'K' ? Как вы уже наверное догадались мы тоже их представим в виде _Объектов-Значений_. Ок, значит теперь мы теперь должны будем инициировать десятку трефа так:
```ruby
ten       = Values::Rank.new('10')
clubs     = Values::Suits.new(:clubs)
ten_clubs = Values::PlayingCards.new(rank: ten, clubs: clubs)
```
Три строчки это достаточно много для ruby. Для того чтобы обойти это ограничение мы введем третье свойство _Объекта-Значения_ - оборачиваемость. Пусть у нас появится специальный метод  класса `.wrap`, который может принимать значения различного типа и преобразовывать их в нужный.
```ruby
class PlayingCard < Lunapark::Value
  def self.wrap(obj)
    case obj.is_a? self.class # Если мы получили объект класса PlayingCard
      obj                     # то мы его и вернем
    case obj.is_a? Hash       # Если мы получили хэш то создадим на его основе
      new(obj)                # Новую игральную карту
    case obj.is_a String      # Если мы получили строку, то последний символ, будет
      new rank: obj[0..-2], suit:[-1]  # мастю, остальные - достоинством карты.
    else                      # если тип не совпадает с ожидаемым
      raise ArgumentError     # выдаем ошибку.
    end
  end
  def initialize(suit:, rank:) # Еще модифицируем инициализатор класса
     @siut = Suit.wrap(siut)   # Это позволит нам оборачивать значения
     @rank = Rank.wrap(rank)
  end
 end
```
Такой подход дает большое приемущество:
```ruby
ten       = Values::Rank.new('10')
clubs     = Values::Suits.new(:clubs)
from_objs = Values::PlayingCard.wrap rank: ten,  suit: clubs
from_hash = Values::PlayingCard.wrap rank: '10', siut: :clubs
from_obj  = Values::PlayingCard.wrap from_objs
from_str  = Values::PlayingCard.wrap '10♣'
```
Все эти карты будут равны между собой. Если метод `wrap` разрастается хорошей пратикой будет вынесение его в отдельный класс, с точки зрения догматического подхода отдельный класс так же будет обязательным.
Хм, а как насчет того, места в колоде? Как узнать явялется ли данная карта козырем? Это не игральная карта. Это _Значение_ игральной карты. Это именно та надпись 10♣ которую вы видете на углу картона.
К _Объекту-Зачению_ нужно относится также как и к примитиву, котрый почему-то не реализовали в ruby. Отсюда возникает последнее свойство _Обеъект-Знаечние_ не привязан ни какому домену.

### Рекомендации
> Среди всего многообразия методов и инструментов, используемых в каждый момент каждого процесса, всегда есть один метод и инструмент, который работает быстрее и лучше остальных
>
> [Фредерик Тейлор](https://ru.wikipedia.org/wiki/%D0%A4%D1%80%D0%B5%D0%B4%D0%B5%D1%80%D0%B8%D0%BA_%D0%A2%D0%B5%D0%B9%D0%BB%D0%BE%D1%80) 1914
##### Арифмитические операции должны возвращать новый объект
``` ruby
# GOOD
class Money < LunaPark::Value
  def +(other)
    other = self.class.wrap(other)
    raise ArgumentError unless same_currency? other
    self.class.new(
      amount: amount + other.amount,
      currency: currency
    )
  end
end
```
##### Атрибуты _Объекта-Значения_ могу быть только примитивами или другими _Объектами-значения_
```ruby
# GOOD
class Weight < LunaPark::Value
  def intialize(value:, unit:)
    @value = value
    @unit  = Unit.wrap(unit)
  end
end
# BAD
class PlaingCard < LunaPark::Value
  def initialize(rank:, suit:, deck:)
    ...
    @deck = Entity::Deck.wrap(deck) # зависимость от сущности
  end
end
```
##### Простые опреации держите внутри методов класса
```ruby
# GOOD
class Weight < LunaPark::Value
  def >(other)
    value > other.convert_to(unit).value
  end
end
```
##### Если операцияя ковертация большая то возможно есть смысл вынести ее в отделььный класс
```ruby
# UGLY
class Weight < LunaPark::Value
  def convert_to(unit)
    unit = Unit.wrap(unit)
    case { self.unit.to_sym => unit.to_sym }
    when { :kg => :ft }
      Weight.new(value: 2.2046 * value, unit.to_sym)
    when ...
    end
  end
end
# GOOD
#./lib/values/weight/converter.rb
class Weight
  class Converter < LunaPark::Service
    def initialize(weight, to:)
      ...
    end
  end
end
#./lib/values/weight.rb
class Weight < LunaPark::Value
  def convert_to(unit)
    Converter.call! self, to: unit
  end
end
```
Такое выенсение логики в отдельный _Сервис_ возможно __только__ при условии того, что _Сервсис_ изолирован: он не использует данные ни с каких внешних источников. Этот сервис должен быть ограничен конткестом самого _Объекта-Значения_
##### Объект значение не может ничего знать о доменной логике
Предположим что мы пишем интернет магазин, и у нас есть рейтинг товаров. И чтобы его получить, необходимо сделать запрос в БД, через _Репозиторий_.
```ruby
# DEADLY BAD
class Rate < LunaPark::Value
  def top?(10)
    Repository::Rates.top(first: 10).include? self
  end
end
```